<!--

TO EMBED

-->
<canvas class="webgl"></canvas>

<!--

TO HEAD

-->


<!--

TO BODY

-->
<script type="text/javascript" src='https://cdnjs.cloudflare.com/ajax/libs/three.js/r125/three.min.js'></script>
<script type="text/javascript" src='https://unpkg.com/three@0.125.2/examples/js/controls/OrbitControls.js'></script>
<script type="text/javascript" src='https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js'></script>
<script type="text/javascript" src='https://unpkg.com/browse/three@0.132.2/examples/jsm/libs/stats.module.js'></script>

<script>
    const canvas = document.querySelector('canvas.webgl')

    // Scene
    const scene = new THREE.Scene()

    /**
     * Textures
     */
    const textureLoader = new THREE.TextureLoader()
    const displacementTexture = textureLoader.load('/textures/displacementMap.png')

    /**
     * Sizes
     */
    const sizes = {
        width: window.innerWidth,
        height: window.innerHeight
    }

    window.addEventListener('resize', () =>
    {
        // Update sizes
        sizes.width = window.innerWidth
        sizes.height = window.innerHeight

        // Update camera
        camera.aspect = sizes.width / sizes.height
        camera.updateProjectionMatrix()

        // Update renderer
        renderer.setSize(sizes.width, sizes.height)
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
    })

    /**
     * Camera
     */
// Base camera
    const camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height, 0.1, 100)
    camera.position.set(2, 2, 6)
    scene.add(camera)

    // Controls
    const controls = new THREE.OrbitControls(camera, canvas)
    controls.enableDamping = true

    /**
     * Renderer
     */
    const renderer = new THREE.WebGLRenderer({
        canvas: canvas,
        powerPreference: 'high-performance',
        antialias: true
    })
    renderer.shadowMap.enabled = true
    renderer.shadowMap.type = THREE.PCFSoftShadowMap
    renderer.setSize(sizes.width, sizes.height)
    renderer.setPixelRatio(window.devicePixelRatio)

    /**
     * Test meshes
     */
    const cube = new THREE.Mesh(
        new THREE.BoxBufferGeometry(2, 2, 2),
        new THREE.MeshStandardMaterial()
    )
    cube.castShadow = true
    cube.receiveShadow = true
    cube.position.set(- 5, 0, 0)
    scene.add(cube)

    const torusKnot = new THREE.Mesh(
        new THREE.TorusKnotBufferGeometry(1, 0.4, 128, 32),
        new THREE.MeshStandardMaterial()
    )
    torusKnot.castShadow = true
    torusKnot.receiveShadow = true
    scene.add(torusKnot)

    const sphere = new THREE.Mesh(
        new THREE.SphereBufferGeometry(1, 32, 32),
        new THREE.MeshStandardMaterial()
    )
    sphere.position.set(5, 0, 0)
    sphere.castShadow = true
    sphere.receiveShadow = true
    scene.add(sphere)

    const floor = new THREE.Mesh(
        new THREE.PlaneBufferGeometry(10, 10),
        new THREE.MeshStandardMaterial()
    )
    floor.position.set(0, - 2, 0)
    floor.rotation.x = - Math.PI * 0.5
    floor.castShadow = true
    floor.receiveShadow = true
    scene.add(floor)

    /**
     * Lights
     */
    const directionalLight = new THREE.DirectionalLight('#ffffff', 1)
    directionalLight.castShadow = true
    directionalLight.shadow.mapSize.set(1024, 1024)
    directionalLight.shadow.camera.far = 15
    directionalLight.shadow.normalBias = 0.05
    directionalLight.position.set(0.25, 3, 2.25)
    scene.add(directionalLight)

    /**
     * Animate
     */
    const clock = new THREE.Clock()

    const tick = () =>
    {
        const elapsedTime = clock.getElapsedTime()

        // Update test mesh
        torusKnot.rotation.y = elapsedTime * 0.1

        // Update controls
        controls.update()

        // Render
        renderer.render(scene, camera)

        // Call tick again on the next frame
        window.requestAnimationFrame(tick)
    }

    tick()
</script>